各类的文件的格式
    dbname/CURRENT
    dbname/LOCK
    dbname/LOG
    dbname/LOG.old
    dbname/MANIFEST-[0-9]+
    dbname/[0-9]+.(log|sst|ldb)
internalKey格式
    AppendInternalKey()函数有说明
    key+sequence<<8|valueType 相比原来的key多了8个byte


skipList的level是0起始

writeBatch的data的格式,要是多个action在1个batch中共享相同的sequence
       WriteBatch::rep_ :=
                  sequence: fixed64
                  count: fixed32
                  data: record[count]
              record :=
                  kTypeValue varstring varstring
                  kTypeDeletion varstring
              varstring :=
                 len: varint32
                 data: uint8[len]

log文件的header
     checksum (4 bytes), length (2 bytes), type (1 byte)
     crc 计算的是 type+后边的跟着的实际的data 函数ReadPhysicalRecord()能够说明
     LOG_HEADER_LEN

manifest 文件其实便是一个 log 文件，一个 log record 就是一个 versionEdit
    https://zhuanlan.zhihu.com/p/149794634

manifest文件中的logRecord的payload是versionEdit
log文件中的logRecord的payLoad是writeBatch内容

似乎logFile的生命周期和memTable相同 落盘成功写到ldb之后，日志文件就可以去掉了
    MakeRoomForWrite() 体现

Compaction 是比较耗费资源的操作，
为了不影响线上的读写操作，LevelDB 将 Compaction 工作交给一个单一的异步线程来完成
如工作量巨大，这个单一的异步线程也会有点吃不消
当异步线程吃不消的时候，线上内存的读写操作也会收到影响
因为只有 rtable 沉到磁盘里了，写满的wtable 才可以变身成为immutableTable
只有 wtable 变身了，才会有新的 wtable 被创建来容纳后续更多的键值对 环环相套

当memtable内存表增长到一定程度时(memtable.size> Options::write_buffer_size)，
原先的Memtable就成为Immutable Memtable。LevelDb后台调度会将Immutable Memtable的数据导出到硬盘，形成一个新的SSTable文件
SSTable(Sorted String Table)就是由内存中的数据不断导出并进行Compaction操作后形成的，
而且SSTable的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，层级逐渐增高，这也是为何称之为LevelDb的原因。
compact会将多个SSTable合并成少量的几个SSTable，以剔除无效数据，保证数据访问效率并降低硬盘占用

从leveldb v1.14版本开始，数据的文件的后缀名由ldb变为sst
    https://blog.csdn.net/xxb249/article/details/94559781